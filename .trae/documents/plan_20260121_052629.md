通过分析 `tree_output.txt` 和 `treewatcher.py` 的解析逻辑，发现问题的原因在于：

当前的解析逻辑在处理特定情况下的缩进块时，为了修复之前的“字符被截断”问题，引入了非标准的缩进解析逻辑（允许非4字符倍数的缩进）。这导致在某些深层嵌套或特定格式的行中，缩进层级计算错误。

具体来说，在 `parse_line` 函数中：
1.  代码尝试通过查找连接符（如 `├`、`└`）来确定层级结束。
2.  当连接符出现在一个 4 字符块的中间时（之前的修复逻辑），它会提前结束缩进计算并认为这是一个新的层级。
3.  对于 `inferencestorage` 及其子目录，由于缩进字符的排列组合（特别是包含空格和竖线的情况），可能导致某一行被错误地判定为比实际层级更浅（即父级），从而使得本该是子目录的 `inferencestorage` 变成了与父级 `Alkaid_datastorage` 平级甚至更高的层级，进而导致其后的子文件夹解析错位。

实际上，标准的 `tree /F` 输出是非常规整的 4 字符对齐。

**修复计划：**

1.  **恢复严格的 4 字符解析逻辑，但保留对“连接符在块内”的特殊处理仅作为“名称开始”的标记，而不是改变缩进块的消耗逻辑**。
2.  核心思路是：缩进层级 **必须** 基于 4 字符块的数量。如果一个块中包含连接符，那么这个块 **仍然算作一级缩进**（或者是这一级的结束），而不应该因为连接符的位置偏移而导致层级计数混乱。
3.  具体的修改点在 `parse_line` 函数：
    -   遍历 4 字符块。
    -   如果块是纯空白或竖线（`│   `、`    `），深度+1，继续下一个块。
    -   如果块包含连接符（`├── `、`└── `），深度+1，停止解析缩进，剩余部分（包括连接符）作为名称的前缀处理。
    -   如果之前的逻辑因为连接符在块中间（例如 ` ├─`）而导致只消耗了部分字符，必须确保这部分被算作完整的 1 个层级深度，并且正确地定位名称的起始位置。

**具体步骤：**

1.  创建一个复现脚本 `reproduce_issue_v2.py`，模拟 `Alkaid_datastorage` -> `inferencestorage` -> `inferencedata` 这种深层结构，特别是包含可能导致解析错误的缩进字符串。
2.  修改 `treewatcher.py` 中的 `parse_line` 方法：
    -   重构循环逻辑，确保每次迭代都完整处理一个“逻辑层级”。
    -   对于包含连接符的块，无论连接符在块内的哪个位置，都将深度加 1，并设置名称起始位置。
3.  使用复现脚本验证修复结果，确保层级关系正确（即 `inferencestorage` 是 `Alkaid_datastorage` 的子节点，`inferencedata` 是 `inferencestorage` 的子节点）。
4.  运行主程序，加载 `tree_output.txt` 确认整体显示正常。

**计划修改的代码逻辑（伪代码）：**

```python
def parse_line(line):
    depth = 0
    idx = 0
    n = len(line)
    
    while idx + 4 <= n:
        chunk = line[idx:idx+4]
        
        # 检查是否是标准的缩进块 (│   或    )
        if chunk == "│   " or chunk == "    ":
            depth += 1
            idx += 4
            continue
            
        # 检查是否包含连接符 (├, └, +, \)
        # 无论连接符在块内的哪个位置，只要出现了，就意味着缩进结束，且当前块算作一级深度
        if any(c in chunk for c in ["├", "└", "+", "\\"]):
             depth += 1
             # 这里不增加 idx，或者根据连接符位置调整，让后续的名称提取逻辑去处理前缀
             # 关键是深度计数要正确
             break 
             
        # 如果既不是标准缩进也不是连接符块，可能就是名称开始了（虽然标准tree输出通常会有连接符）
        break
        
    # 提取名称并去除前缀...
```
这个逻辑比之前的更健壮，因为它强制基于 4 字符块来计算深度，符合 `tree` 命令的输出规范。
